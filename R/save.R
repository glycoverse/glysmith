#' Save GlySmith Result
#'
#' Save processed experiment, plots and tables of a glysmith result object to a directory.
#' A `README.md` file will also be generated to describe the saved outputs,
#' based on metadata in `x$meta`.
#'
#' @param x A glysmith result object.
#' @param dir The directory to save the result.
#' @param plot_ext The extension of the plot files. Either "pdf", "png" or "svg". Default is "pdf".
#' @param table_ext The extension of the table files. Either "csv" or "tsv". Default is "csv".
#' @param plot_width The width of the plot in inches. Default is 5.
#' @param plot_height The height of the plot in inches. Default is 5.
#'
#' @returns A glysmith result object.
#' @examples
#' library(glyexp)
#' exp <- real_experiment
#' result <- forge_analysis(exp)
#' quench_result(result, tempdir())
#'
#' @export
quench_result <- function(x, dir, plot_ext = "pdf", table_ext = "csv", plot_width = 5, plot_height = 5) {
  checkmate::assert_class(x, "glysmith_result")
  checkmate::assert_string(dir)
  checkmate::assert_choice(plot_ext, c("pdf", "png", "svg"))
  checkmate::assert_choice(table_ext, c("csv", "tsv"))

  if (fs::dir_exists(dir)) {
    cli::cli_alert_info("Directory already exists. Overwrite? [y/N]")
    ans <- readline()
    ans <- tolower(ans)
    if (ans == "n") {
      cli::cli_abort("Operation cancelled. Result not saved.")
    } else if (ans == "y" || ans == "") {
      fs::dir_delete(dir)
    } else {
      cli::cli_abort("Invalid input. Operation cancelled. Result not saved.")
    }
  }

  fs::dir_create(dir, recurse = TRUE)
  fs::dir_create(fs::path(dir, "plots"))
  fs::dir_create(fs::path(dir, "tables"))

  for (plot in names(x$plots)) {
    file_path <- fs::path(dir, "plots", paste0(plot, ".", plot_ext))
    ggsave_args <- list(
      filename = file_path,
      plot = cast_plot(x, plot),
      width = plot_width,
      height = plot_height
    )
    ggsave_formals <- names(formals(ggplot2::ggsave))
    if ("verbose" %in% ggsave_formals) ggsave_args$verbose <- FALSE
    if ("quiet" %in% ggsave_formals) ggsave_args$quiet <- TRUE
    .quietly(do.call(ggplot2::ggsave, ggsave_args))
  }

  for (table in names(x$tables)) {
    file_path <- fs::path(dir, "tables", paste0(table, ".", table_ext))
    writer <- switch(table_ext, "csv" = readr::write_csv, "tsv" = readr::write_tsv)
    .quietly(writer(cast_table(x, table), file_path))
  }

  readr::write_rds(x$exp, fs::path(dir, "experiment.rds"))
  readr::write_rds(x$meta, fs::path(dir, "meta.rds"))

  .write_result_readme(x, dir, plot_ext = plot_ext, table_ext = table_ext)

  cli::cli_alert_success("Result saved to {.path {dir}}")
}

#' Write README.md for GlySmith Result
#'
#' Write a README.md file to describe the saved outputs,
#' based on metadata in `x$meta`.
#'
#' @param x A glysmith result object.
#' @param dir The directory to save the result.
#' @param plot_ext The extension of the plot files.
#' @param table_ext The extension of the table files.
#' @noRd
.write_result_readme <- function(x, dir, plot_ext, table_ext) {
  # Generate a human-readable README for exported results.
  explanation <- NULL
  steps <- NULL
  if (!is.null(x$meta) && is.list(x$meta)) {
    explanation <- x$meta$explanation
    steps <- x$meta$steps
  }
  if (is.null(explanation)) explanation <- character(0)

  .explain <- function(key, default) {
    # Safely get explanation text by key.
    if (is.null(explanation)) return(default)
    if (is.list(explanation)) {
      if (key %in% names(explanation)) {
        val <- explanation[[key]]
        if (!is.null(val) && !is.na(val) && nzchar(val)) return(val)
      }
      return(default)
    }
    val <- explanation[key]
    if (length(val) == 1 && !is.na(val) && nzchar(val)) return(unname(val))
    default
  }

  lines <- c(
    "# GlySmith result directory",
    "",
    "This directory was generated by `glysmith::quench_result()`.",
    "",
    "## Files",
    "",
    "- `experiment.rds`: Processed experiment object.",
    "- `meta.rds`: Metadata list (including explanations and analysis steps).",
    "- `plots/`: Figures generated by the analysis pipeline.",
    "- `tables/`: Tabular outputs generated by the analysis pipeline.",
    "",
    "## Plots",
    ""
  )

  plot_names <- names(x$plots)
  if (length(plot_names) == 0) {
    lines <- c(lines, "_(none)_", "")
  } else {
    for (nm in plot_names) {
      key <- paste0("plots$", nm)
      desc <- .explain(key, default = "Plot output.")
      lines <- c(lines, sprintf("- `plots/%s.%s`: %s", nm, plot_ext, desc))
    }
    lines <- c(lines, "")
  }

  lines <- c(lines, "## Tables", "")
  table_names <- names(x$tables)
  if (length(table_names) == 0) {
    lines <- c(lines, "_(none)_", "")
  } else {
    for (nm in table_names) {
      key <- paste0("tables$", nm)
      desc <- .explain(key, default = "Table output.")
      lines <- c(lines, sprintf("- `tables/%s.%s`: %s", nm, table_ext, desc))
    }
    lines <- c(lines, "")
  }

  if (!is.null(steps) && length(steps) > 0) {
    lines <- c(lines, "## Analysis steps", "")
    lines <- c(lines, paste0("- ", steps), "")
  }

  writeLines(lines, fs::path(dir, "README.md"), useBytes = TRUE)
  invisible(NULL)
}

.quietly <- function(expr) {
  # Silence stdout/stderr output for clean interactive console.
  expr <- substitute(expr)
  tmp <- tempfile("glysmith-quiet-")
  con <- file(tmp, open = "wt")
  out0 <- sink.number()
  msg0 <- sink.number(type = "message")
  sink(con)
  sink(con, type = "message")
  on.exit({
    # Restore sinks created in this helper only.
    while (sink.number(type = "message") > msg0) sink(type = "message")
    while (sink.number() > out0) sink()
    close(con)
    unlink(tmp)
  }, add = TRUE)

  eval(expr, envir = parent.frame())
  invisible(NULL)
}