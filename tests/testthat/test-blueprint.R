test_that("blueprint checks ctx$data dependencies", {
  expect_no_error(blueprint(
    step_dea_limma(),
    step_volcano()
  ))
  # Use expect_error instead of expect_snapshot to avoid message capture differences
  # between test() and R CMD check environments
  my_step <- step("my_step", "My Step", function(ctx) ctx, require = "dea_res")
  expect_error(
    blueprint(my_step),
    class = "rlang_error"
  )
})

test_that("blueprint checks overwrites", {
  step1 <- step("step1", "Step 1", function(ctx) ctx, generate = "x")
  step2 <- step("step2", "Step 2", function(ctx) ctx, generate = "x")
  expect_snapshot(blueprint(step1, step2))
})

test_that("blueprint check duplicated steps", {
  step1 <- step("step1", "Step 1", function(ctx) ctx, generate = "x")
  step2 <- step("step2", "Step 2", function(ctx) ctx, require = "x")
  expect_error(
    blueprint(step1, step1, step2, step2),
    class = "rlang_error"
  )
})

test_that("writing and loading blueprint works", {
  bp <- blueprint(
    step_dea_limma(),
    step_volcano()
  )
  file <- tempfile(fileext = ".rds")
  write_blueprint(bp, file)
  expect_s3_class(read_blueprint(file), "glysmith_blueprint")
})

test_that("br expands into namespaced steps", {
  step1 <- step("step1", "Step 1", function(ctx) ctx, generate = "x")
  step2 <- step("step2", "Step 2", function(ctx) ctx, require = "x")
  bp <- blueprint(
    br("branch1", step1, step2),
    br("branch2", step1, step2)
  )
  expect_s3_class(bp, "glysmith_blueprint")
  expect_true(
    all(
      stringr::str_starts(names(bp), "branch1__") |
        stringr::str_starts(names(bp), "branch2__")
    )
  )
})

test_that("blueprint prints branches", {
  bp <- blueprint(
    step_preprocess(),
    br("branch1", step_dea_limma(), step_volcano()),
    br("branch2", step_dea_ttest(), step_volcano())
  )
  expect_snapshot(bp)
})

test_that("br inherits dependencies from main flow", {
  # trait_exp is generated by step_derive_traits() in the main flow
  # step_pca(on = "trait_exp") requires trait_exp
  # Validation should pass because it can fall back to "trait_exp"
  bp <- blueprint(
    step_derive_traits(),
    br("branch1", step_pca(on = "trait_exp"))
  )
  expect_s3_class(bp, "glysmith_blueprint")

  # But it should still fail if the dependency is truly missing
  expect_error(
    blueprint(
      br("branch1", step_pca(on = "trait_exp"))
    ),
    "missing step dependencies"
  )
})

test_that("branch step error shows unprefixed key and placement hint", {
  # When a step inside a branch has a missing dependency, the error should:
  # 1. Show the original step (step_volcano()) with branch context
  # 2. Show the unprefixed key (dea_res, not d__dea_res)
  # 3. Include a hint about where to place generating steps
  err <- tryCatch(
    blueprint(br("d", step_volcano())),
    error = identity
  )

  expect_true(inherits(err, "rlang_error"))
  msg <- conditionMessage(err)

  # Should show the original step name with branch context
  expect_true(grepl('step_volcano\\(\\).*in the "d" branch', msg))
  # Should show unprefixed key
  expect_true(grepl("dea_res", msg))
  # Should include placement hint
  expect_true(grepl(
    "The required step should be placed before.*step_volcano",
    msg
  ))
})
